const OpenAI = require('openai');
const { logger } = require('../utils/logger');

// Initialize OpenAI (optional - graceful degradation if not configured)
let openai = null;
if (process.env.OPENAI_API_KEY && process.env.OPENAI_API_KEY !== 'your_openai_api_key_here') {
  openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
}

/**
 * Generate dynamic interview questions based on job description
 */
const generateInterviewQuestions = async (job, difficulty = 'moderate', count = 10) => {
  if (!openai) {
    return generateFallbackQuestions(job, count);
  }

  try {
    const prompt = `Generate ${count} ${difficulty} interview questions for a ${job.title} position.
    
Job Description: ${job.description}
Required Skills: ${job.requiredSkills?.join(', ')}
Experience Level: ${job.experienceLevel}

Generate questions that test:
1. Technical knowledge (40%)
2. Problem-solving ability (30%)
3. Communication skills (20%)
4. Behavioral competency (10%)

Return as JSON array with format:
[{
  "id": 1,
  "question": "question text",
  "type": "technical|behavioral|problem-solving",
  "difficulty": "easy|medium|hard",
  "expectedKeywords": ["keyword1", "keyword2"],
  "followUpTriggers": ["trigger phrase that requires follow-up"]
}]`;

    const response = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.7,
      response_format: { type: 'json_object' }
    });

    const questions = JSON.parse(response.choices[0].message.content);
    return questions.questions || questions;
  } catch (error) {
    logger.error('AI question generation failed:', error);
    return generateFallbackQuestions(job, count);
  }
};

/**
 * Generate dynamic follow-up question based on candidate's answer
 */
const generateFollowUpQuestion = async (originalQuestion, candidateAnswer, job) => {
  if (!openai) return null;

  try {
    const prompt = `Based on this interview context, generate a follow-up question:

Original Question: ${originalQuestion}
Candidate's Answer: ${candidateAnswer}
Job: ${job.title}

Generate a follow-up question that:
1. Tests deeper understanding of their answer
2. Challenges vague or surface-level responses
3. Explores practical application

Return JSON: {"followUp": "question text", "reason": "why this follow-up is needed"}`;

    const response = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.8,
      max_tokens: 200
    });

    return JSON.parse(response.choices[0].message.content);
  } catch (error) {
    logger.error('Follow-up generation failed:', error);
    return null;
  }
};

/**
 * Detect AI-generated content (Plagiarism Detection)
 */
const detectAIContent = async (text) => {
  if (!openai) {
    return { isAIGenerated: false, confidence: 0, reason: 'Detection unavailable' };
  }

  try {
    const prompt = `Analyze if this text was likely generated by AI (ChatGPT, etc.):

"${text}"

Look for:
1. Overly formal or perfect grammar
2. Lack of personal anecdotes or specific examples
3. Generic corporate language
4. Absence of filler words or natural speech patterns
5. Suspiciously comprehensive answers

Return JSON: {
  "isAIGenerated": true/false,
  "confidence": 0-100,
  "indicators": ["reason1", "reason2"],
  "recommendation": "LOW_RISK|MEDIUM_RISK|HIGH_RISK"
}`;

    const response = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.3,
      response_format: { type: 'json_object' }
    });

    return JSON.parse(response.choices[0].message.content);
  } catch (error) {
    logger.error('AI detection failed:', error);
    return { isAIGenerated: false, confidence: 0, reason: 'Detection failed' };
  }
};

/**
 * Analyze speech patterns for behavioral metrics
 */
const analyzeSpeechPatterns = (transcript, audioDuration) => {
  const text = transcript.toLowerCase();
  
  // Count filler words
  const fillers = ['um', 'uh', 'like', 'you know', 'actually', 'basically', 'literally'];
  let fillerCount = 0;
  fillers.forEach(filler => {
    const regex = new RegExp(`\\b${filler}\\b`, 'gi');
    fillerCount += (text.match(regex) || []).length;
  });

  // Calculate speech rate (words per minute)
  const wordCount = text.split(/\s+/).length;
  const speechRate = audioDuration > 0 ? (wordCount / audioDuration) * 60 : 0;

  // Fluency score (inverse of filler ratio)
  const fillerRatio = wordCount > 0 ? fillerCount / wordCount : 0;
  const fluencyScore = Math.max(0, Math.min(100, 100 - (fillerRatio * 200)));

  return {
    fillerCount,
    fillerRatio: parseFloat(fillerRatio.toFixed(3)),
    speechRate: parseFloat(speechRate.toFixed(1)),
    wordCount,
    fluencyScore: Math.round(fluencyScore),
    assessment: fluencyScore > 80 ? 'Excellent' : fluencyScore > 60 ? 'Good' : fluencyScore > 40 ? 'Fair' : 'Needs Improvement'
  };
};

/**
 * Perform sentiment analysis on text
 */
const analyzeSentiment = async (text) => {
  if (!openai) {
    return { sentiment: 'neutral', positivity: 50, professionalism: 50 };
  }

  try {
    const prompt = `Analyze the sentiment and professionalism of this interview response:

"${text}"

Return JSON: {
  "sentiment": "positive|neutral|negative",
  "positivity": 0-100,
  "professionalism": 0-100,
  "tone": "confident|uncertain|defensive|enthusiastic",
  "concerns": ["any red flags"]
}`;

    const response = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.3,
      response_format: { type: 'json_object' }
    });

    return JSON.parse(response.choices[0].message.content);
  } catch (error) {
    logger.error('Sentiment analysis failed:', error);
    return { sentiment: 'neutral', positivity: 50, professionalism: 50 };
  }
};

/**
 * Evaluate answer with enhanced scoring
 */
const evaluateAnswer = async (question, answer, job, strictness = 'moderate') => {
  if (!openai) {
    return generateFallbackEvaluation(question, answer);
  }

  try {
    const strictnessMultiplier = {
      lenient: 1.1,
      moderate: 1.0,
      strict: 0.9
    };

    const prompt = `Evaluate this interview answer with ${strictness} strictness:

Question: ${question.question}
Expected Keywords: ${question.expectedKeywords?.join(', ')}
Candidate's Answer: ${answer}
Job Context: ${job.title}

Provide scores (0-100) for:
1. Technical Accuracy
2. Completeness
3. Clarity
4. Relevance

Return JSON: {
  "technicalScore": 0-100,
  "completeness": 0-100,
  "clarity": 0-100,
  "relevance": 0-100,
  "overallScore": 0-100,
  "feedback": "constructive feedback",
  "strengths": ["strength1"],
  "improvements": ["area1"]
}`;

    const response = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.4,
      response_format: { type: 'json_object' }
    });

    const evaluation = JSON.parse(response.choices[0].message.content);
    
    // Apply strictness multiplier
    const multiplier = strictnessMultiplier[strictness] || 1.0;
    evaluation.overallScore = Math.min(100, Math.round(evaluation.overallScore * multiplier));
    evaluation.score = evaluation.overallScore; // Add score field for compatibility

    return evaluation;
  } catch (error) {
    logger.error('Answer evaluation failed:', error);
    return generateFallbackEvaluation(question, answer);
  }
};

/**
 * Generate comprehensive interview report
 */
const generateComprehensiveReport = async (interview) => {
  const responses = interview.responses || [];
  
  let totalTechnical = 0;
  let totalCommunication = 0;
  let totalProblemSolving = 0;
  let totalSoftSkills = 0;
  let totalConfidence = 0;
  let totalFluency = 0;
  let totalProfessionalism = 0;
  let totalIntegrity = 100; // Start at 100, deduct for issues
  
  const plagiarismFlags = [];
  const behavioralInsights = [];

  // Analyze each response
  for (const response of responses) {
    totalTechnical += response.score || 0;
    
    // Check for plagiarism
    if (response.plagiarismCheck) {
      if (response.plagiarismCheck.isAIGenerated) {
        totalIntegrity -= 20;
        plagiarismFlags.push({
          questionIndex: response.questionIndex,
          confidence: response.plagiarismCheck.confidence,
          indicators: response.plagiarismCheck.indicators
        });
      }
    }

    // Aggregate behavioral metrics
    if (response.sentimentAnalysis) {
      totalProfessionalism += response.sentimentAnalysis.professionalismScore || 50;
      totalConfidence += response.sentimentAnalysis.positivity || 50;
    }

    // Speech analysis
    if (response.speechAnalysis) {
      totalFluency += response.speechAnalysis.fluencyScore || 50;
    }
  }

  const responseCount = responses.length || 1;
  const avgTechnical = Math.round(totalTechnical / responseCount);
  const avgCommunication = Math.round((totalFluency + totalProfessionalism) / (2 * responseCount));
  const avgProblemSolving = avgTechnical; // Simplified
  const avgSoftSkills = Math.round((totalConfidence + totalProfessionalism) / (2 * responseCount));
  const avgConfidence = Math.round(totalConfidence / responseCount);
  const avgFluency = Math.round(totalFluency / responseCount);
  const avgProfessionalism = Math.round(totalProfessionalism / responseCount);
  const integrityScore = Math.max(0, totalIntegrity);

  // Determine integrity risk
  let integrityRisk = 'LOW';
  if (integrityScore < 50) integrityRisk = 'HIGH';
  else if (integrityScore < 75) integrityRisk = 'MEDIUM';

  // Anti-cheat analysis
  const antiCheat = interview.antiCheatData || {};
  if (antiCheat.tabSwitches > 5) {
    integrityScore = Math.max(0, integrityScore - 10);
    integrityRisk = integrityRisk === 'LOW' ? 'MEDIUM' : 'HIGH';
  }

  const overallScore = Math.round(
    (avgTechnical * 0.4) + 
    (avgCommunication * 0.2) + 
    (avgProblemSolving * 0.2) + 
    (avgSoftSkills * 0.1) + 
    (integrityScore * 0.1)
  );

  return {
    overallScore,
    technicalScore: avgTechnical,
    communicationScore: avgCommunication,
    problemSolvingScore: avgProblemSolving,
    softSkillsScore: avgSoftSkills,
    confidenceScore: avgConfidence,
    fluencyScore: avgFluency,
    professionalismScore: avgProfessionalism,
    integrityScore,
    integrityRisk,
    plagiarismFlags,
    antiCheatSummary: {
      tabSwitches: antiCheat.tabSwitches || 0,
      copyPasteAttempts: antiCheat.copyPasteAttempts || 0,
      suspiciousActivities: antiCheat.suspiciousActivities?.length || 0
    },
    recommendation: integrityScore > 75 && avgTechnical > 70 ? 'STRONG_HIRE' : 
                    integrityScore > 60 && avgTechnical > 60 ? 'CONSIDER' : 'REJECT',
    summary: `Technical: ${avgTechnical}%, Communication: ${avgCommunication}%, Soft Skills: ${avgSoftSkills}%, Integrity: ${integrityScore}% (${integrityRisk} risk)`,
    detailedFeedback: {
      strengths: [],
      improvements: [],
      concerns: plagiarismFlags.length > 0 ? ['Potential AI-generated content detected'] : []
    }
  };
};

/**
 * Generate comprehensive interview report (alias for compatibility)
 */
const generateReport = generateComprehensiveReport;

/**
 * Fallback functions when AI is not available
 */
function generateFallbackQuestions(job, count) {
  const questions = [];
  for (let i = 1; i <= count; i++) {
    questions.push({
      id: i,
      question: `Question ${i}: Tell me about your experience with ${job.requiredSkills?.[0] || 'this role'}.`,
      type: 'technical',
      difficulty: 'medium',
      expectedKeywords: job.requiredSkills || [],
      followUpTriggers: []
    });
  }
  return questions;
}

function generateFallbackEvaluation(question, answer) {
  const wordCount = answer.split(/\s+/).length;
  const score = Math.min(100, wordCount * 5); // Simple word count scoring
  
  return {
    technicalScore: score,
    completeness: score,
    clarity: score,
    relevance: score,
    overallScore: score,
    feedback: 'Answer received and recorded.',
    strengths: ['Response provided'],
    improvements: ['Consider adding more details']
  };
}

module.exports = {
  generateInterviewQuestions,
  generateFollowUpQuestion,
  detectAIContent,
  analyzeSpeechPatterns,
  analyzeSentiment,
  evaluateAnswer,
  generateReport,
  generateComprehensiveReport
};
